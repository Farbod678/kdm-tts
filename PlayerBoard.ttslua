require("Kdm/Check")
local Util = require("Kdm/Util")
local Log = require("Kdm/Log").ForPackage("PlayerBoard")
local Zone = require("Kdm/Zone")
local EventManager = require("Kdm/EventManager")
local Ui = require("Kdm/Ui3d")
local Location = require("Kdm/Location")
local NamedObject = require("Kdm/NamedObject")

local CharSheet = nil
local Armor = nil
local Weapon = nil

---------------------------------------------------------------------------------------------------

local PlayerBoard_playerBoardsByObject = {}
local PlayerBoard_playerBoards = {}

local PLAYER_BOARD_ARMOR_LOCATIONS = { "head", "arms", "body", "waist", "legs" }
local PLAYER_BOARD_HEAVY_INJURY_LOCATIONS = { "head", "arms", "body", "waist", "legs" }
local PLAYER_BOARD_LIGHT_INJURY_LOCATIONS = { "arms", "body", "waist", "legs" }

local PLAYER_BOARD_TOKEN_STATS = {
    ["Movement Token"] = "movement",
    ["Speed Token"] = "speed",
    ["Accuracy Token"] = "accuracy",
    ["Strength Token"] = "strength",
    ["Evasion Token"] = "evasion",
    ["Luck Token"] = "luck",
}

---------------------------------------------------------------------------------------------------

local PlayerBoard_gearCellByZone = {}

local function PlayerBoard_GearCellFromZones(zones)
    for _, zone in ipairs(zones) do
        local gearCell = PlayerBoard_gearCellByZone[zone]
        if gearCell then
            return gearCell
        end
    end
    return nil
end

---------------------------------------------------------------------------------------------------


local PlayerBoardClass = {}
PlayerBoardClass.__index = PlayerBoardClass

local function PlayerBoard_Create(playerNumber, object, saveState)
    Log.Debugf("Creating PlayerBoard for object %s (%s)", object.getName(), object.getGUID())
    saveState = saveState or {}

    local playerBoard = {
        tag = "PlayerBoard",

        playerNumber = playerNumber,

        object = object,

        gearCells = {},

        linkedArmor = {},
        linkedWeapons = {},
        linkedGearTokens = {},
        linkedTemporaryTokens = {},
        linkedPermanentTokens = {},
        linkedMiscTokens = {},
    }
    setmetatable(playerBoard, PlayerBoardClass)

    local playerGearPrefix = "Player "..playerNumber.." Gear "
    for _, name in ipairs({ "1 1", "1 2", "1 3", "2 1", "2 2", "2 3", "3 1", "3 2", "3 3" }) do
        local cell = { name = name, tokens = {} }
        playerBoard.gearCells[name] = cell
        PlayerBoard_gearCellByZone[playerGearPrefix..name] = cell
    end
    local fistToothCell = { name = "Fist & Tooth", tokens = {} }
    playerBoard.gearCells["Fist & Tooth"] = fistToothCell
    PlayerBoard_gearCellByZone["Player "..playerNumber.." Fist & Tooth"] = fistToothCell

    for _, hitLocation in ipairs(PLAYER_BOARD_ARMOR_LOCATIONS) do
        local temp = hitLocation.."TemporaryArmor"
        playerBoard[temp] = saveState[temp] or 0
        playerBoard[hitLocation.."GearArmor"] = 0
    end

    for _, hitLocation in ipairs(PLAYER_BOARD_LIGHT_INJURY_LOCATIONS) do
        local inj = hitLocation.."LightInjury"
        playerBoard[inj] = saveState[inj]
    end

    for _, hitLocation in ipairs(PLAYER_BOARD_HEAVY_INJURY_LOCATIONS) do
        local inj = hitLocation.."HeavyInjury"
        playerBoard[inj] = saveState[inj]
    end

    if saveState.figurineGuid then
        figurine = getObjectFromGUID(saveState.figurineGuid)
        if not figurine then
            Log.Errorf("Player Board %d was linked to Figurine %s, but that object no longer exists. Please re-link player %d with a survivor figurine.", playerNumber, saveState.figurineGuid, playerNumber)
        else
            playerBoard:LinkFigurine(figurine)
        end
    end

    local checkBoxSize = 0.0548
    local y = -0.972599

    local topLeft = { x = 0.011453, y = y }
    local bottomRight = { x = topLeft.x - checkBoxSize, y = y + checkBoxSize }
    playerBoard.headHeavyInjuryCheckBox = Ui.CheckBox({ object = object, id = "HeadHeavyInjury", topLeft = topLeft, bottomRight = bottomRight, scale = 0.075, checked = playerBoard.headHeavyInjury, onClick = function()
        local value = not playerBoard.headHeavyInjury
        Log.Debugf("Setting PlayerBoard %d (%s) headHeavyInjury to %s", playerBoard.playerNumber, playerBoard.object.getGUID(), tostring(value))
        playerBoard.headHeavyInjury = value
        playerBoard.headHeavyInjuryCheckBox:Set(value)
    end })

    local hitLocations = { "arms", "body", "waist", "legs" }

    local x1 = -0.152743
    local xn = -0.736928
    local dx = (xn - x1) / 3
    for i, hitLocation in ipairs(hitLocations) do
        local topLeft = { x = x1 + (i - 1) * dx, y = y }
        local bottomRight = { x = topLeft.x - checkBoxSize, y = y + checkBoxSize }
        local field = hitLocation.."LightInjury"
        playerBoard[field.."CheckBox"] = Ui.CheckBox({ object = object, id = Util.Capitalize(field), topLeft = topLeft, bottomRight = bottomRight, scale = 0.075, checked = playerBoard[field], onClick = function()
            local value = not playerBoard[field]
            Log.Debugf("Setting PlayerBoard %d %s to %s", playerBoard.playerNumber, field, tostring(value))
            playerBoard[field] = value
            playerBoard[field.."CheckBox"]:Set(value)
        end })
    end

    local x1 = -0.214888
    local xn = -0.799133
    for i, hitLocation in ipairs(hitLocations) do
        local topLeft = { x = x1 + (i - 1) * dx, y = y }
        local bottomRight = { x = topLeft.x - checkBoxSize, y = y + checkBoxSize }
        local field = hitLocation.."HeavyInjury"
        playerBoard[field.."CheckBox"] = Ui.CheckBox({ object = object, id = Util.Capitalize(field), topLeft = topLeft, bottomRight = bottomRight, scale = 0.075, checked = playerBoard[field], onClick = function()
            local value = not playerBoard[field]
            Log.Debugf("Setting PlayerBoard %d %s to %s", playerBoard.playerNumber, field, tostring(value))
            playerBoard[field] = value
            playerBoard[field.."CheckBox"]:Set(value)
        end })
    end

    local x1 = 0.047596
    local x2 = -0.087452
    local width = x2 - x1
    local y1 = -0.912613
    local y2 = -0.780076
    local xn = -0.727698
    local dx = (xn - x1) / 4
    for i, hitLocation in ipairs(PLAYER_BOARD_ARMOR_LOCATIONS) do
        local topLeft = { x = x1 + (i - 1) * dx, y = y1 }
        local bottomRight = { x = topLeft.x + width, y = y2 }
        local value = playerBoard[hitLocation.."TemporaryArmor"] + playerBoard[hitLocation.."GearArmor"]
        playerBoard[hitLocation.."ArmorCounter"] = Ui.Counter({ object = object, id = Util.Capitalize(hitLocation.."Armor"), topLeft = topLeft, bottomRight = bottomRight, scale = 0.07, value = value, onValueChanged = function(delta)
            playerBoard:AddArmor(hitLocation, delta, 0)
        end })
    end

    local topLeft = { x = -0.004649, y = -0.687242 }
    local bottomRight = { x = -0.212906, y = -0.623098 }
    Ui.Button({ object = object, id = "HealAndReset", topLeft = topLeft, bottomRight = bottomRight, scale = 0.07, onClick = function()
        playerBoard:HealAndReset(playerBoard)
    end})

    topLeft.y = -0.610934
    bottomRight.y = -0.549081
    Ui.Button({ object = object, id = "PackSurvivor", topLeft = topLeft, bottomRight = bottomRight, scale = 0.07, onClick = function()
        playerBoard:PackCharSheet(playerBoard)
    end})

    return playerBoard
end

---------------------------------------------------------------------------------------------------

function PlayerBoardClass.Save(playerBoard)
    local saveState = {}

    for _, hitLocation in ipairs(PLAYER_BOARD_ARMOR_LOCATIONS) do
        local field = hitLocation.."TemporaryArmor"
        saveState[field] = playerBoard[field]
    end

    for _, hitLocation in ipairs(PLAYER_BOARD_LIGHT_INJURY_LOCATIONS) do
        local field = hitLocation.."LightInjury"
        saveState[field] = playerBoard[field]
    end

    for _, hitLocation in ipairs(PLAYER_BOARD_HEAVY_INJURY_LOCATIONS) do
        local field = hitLocation.."HeavyInjury"
        saveState[field] = playerBoard[field]
    end

    if playerBoard.figurine then
        saveState.figurineGuid = playerBoard.figurine.getGUID()
    end

    return saveState
end

---------------------------------------------------------------------------------------------------

function PlayerBoardClass.Number(playerBoard) return playerBoard.playerNumber end
function PlayerBoardClass.Figurine(playerBoard) return playerBoard.figurine end
function PlayerBoardClass.CharSheet(playerBoard) return playerBoard.linkedCharSheet end
function PlayerBoardClass.Color(playerBoard) return NamedObject.Get("Player "..playerBoard.playerNumber.." Marker").getColorTint() end
function PlayerBoardClass.Armor(playerBoard) return playerBoard.linkedArmor end

function PlayerBoardClass.Weapons(playerBoard)
    local results = {}
    for object, data in pairs(playerBoard.linkedWeapons) do
        local modifiers = {}
        if data.gearCell then
            for _, token in pairs(data.gearCell.tokens) do
                table.insert(modifiers, token)
            end
        end
        table.insert(results, {
            name = object.getName(),
            stats = data.stats,
            modifiers = modifiers,
        })
    end
    return results
end

---------------------------------------------------------------------------------------------------

function PlayerBoardClass.AddArmor(playerBoard, hitLocation, temporaryArmor, gearArmor)
    Log.Debugf("Adding %d temporary/%d gear armor to %s to %s", temporaryArmor, gearArmor, hitLocation, playerBoard.object.getName())

    local oldTemporaryArmor = playerBoard[hitLocation.."TemporaryArmor"]
    local oldGearArmor = playerBoard[hitLocation.."GearArmor"]
    local newTemporaryArmor = oldTemporaryArmor + temporaryArmor
    local newGearArmor = oldGearArmor + gearArmor
    playerBoard[hitLocation.."TemporaryArmor"] = newTemporaryArmor
    playerBoard[hitLocation.."GearArmor"] = newGearArmor
    if (oldTemporaryArmor + oldGearArmor) != (newTemporaryArmor + newGearArmor) then
        playerBoard[hitLocation.."ArmorCounter"]:Set(newTemporaryArmor + newGearArmor)
    end
end

---------------------------------------------------------------------------------------------------

function PlayerBoardClass.LinkFigurine(playerBoard, figurine)
    Log.Debugf("Linking figurine %s (%s) with player %d", figurine.getName(), figurine.getGUID(), playerBoard.playerNumber)

    playerBoard:UnlinkFigurine()

    for i, pb in ipairs(PlayerBoard_playerBoards) do
        if pb.figurine == object then
            pb:UnlinkFigurine()
        end
    end

    playerBoard.figurine = figurine
    local marker = NamedObject.Get("Player "..playerBoard.playerNumber.." Marker")
    figurine.setColorTint(marker.getColorTint())

    if playerBoard.linkedCharSheet then
        playerBoard.linkedCharSheet:LinkFigurine(figurine)
    end
    playerBoard.figurine = figurine

    Log.Printf("Linked figurine %s to player %s", figurine.getName(), playerBoard.playerNumber)
end

---------------------------------------------------------------------------------------------------

function PlayerBoardClass.UnlinkFigurine(playerBoard)
    local figurine = playerBoard.figurine
    if not figurine then
        return
    end

    Log.Debugf("Unlinking figurine %s (%s) from player %d", figurine.getName(), figurine.getGUID(), playerBoard.playerNumber)
    figurine.setColorTint({ r = 0, g = 0, b = 0 })
    if playerBoard.linkedCharSheet then
        playerBoard.linkedCharSheet:UnlinkFigurine()
    end
    playerBoard.figurine = nil
end

---------------------------------------------------------------------------------------------------

function PlayerBoardClass.HealAndReset(playerBoard)
    Log.Debugf("Healing and resetting %s", playerBoard.object.getName())

    -- Clear injuries
    for _, hitLocation in ipairs(PLAYER_BOARD_LIGHT_INJURY_LOCATIONS) do
        local field = hitLocation.."LightInjury"
        if playerBoard[field] then
            playerBoard[field] = false
            playerBoard[hitLocation.."LightInjuryCheckBox"]:Set(false)
        end
    end
    for _, hitLocation in ipairs(PLAYER_BOARD_HEAVY_INJURY_LOCATIONS) do
        local field = hitLocation.."HeavyInjury"
        if playerBoard[field] then
            playerBoard[field] = false
            playerBoard[hitLocation.."HeavyInjuryCheckBox"]:Set(false)
        end
    end

    -- Reset armor
    for _, hitLocation in ipairs(PLAYER_BOARD_ARMOR_LOCATIONS) do
        local field = hitLocation.."TemporaryArmor"
        if playerBoard[field] != 0 then
            playerBoard[field] = 0
            playerBoard[hitLocation.."ArmorCounter"]:Set(playerBoard[hitLocation.."GearArmor"])
        end
    end

    -- Clear temp tokens
    for obj, _ in pairs(playerBoard.linkedTemporaryTokens) do
        if obj != nil then
            obj.destruct()
        end
    end
    playerBoard.linkedTemporaryTokens = {}

    -- Clear bleeding and lunacy tokens
    for obj, _ in pairs(playerBoard.linkedMiscTokens) do
        if obj != nil then
            obj.destruct()
        end
    end
    playerBoard.linkedMiscTokens = {}

    -- Reset char sheet
    if playerBoard.linkedCharSheet then
        playerBoard.linkedCharSheet:HealAndReset()
    end
end

---------------------------------------------------------------------------------------------------

function PlayerBoardClass.PackCharSheet(playerBoard)
    local charSheet = playerBoard.linkedCharSheet
    if charSheet == nil then
        return
    end

    local packedBag, packedCards = charSheet:PackedData()
    if packedCards then
        Log.Printf("%s is already packed. Pick up and drop the character sheet to unpack.", charSheet.NameOrUnnamed())
        return
    end

    local charSheetObj = charSheet.object
    charSheetObj.setLock(false)

    -- scan all cards
    local hits = Location.Get("Player "..playerBoard.playerNumber.." Cards"):BoxCast()
    local cards = {}
    for _, hit in ipairs(hits) do
        local hitObj = hit.hit_object
        if hitObj.tag == "Card" then
            table.insert(cards, hitObj)
        end
    end

    if #cards == 0 and playerBoard.figurine == nil then
        Log.Printf("Nothing to pack!")
        return
    end

    Log.Debugf("Putting player cards and figurine in bag")

    local playerBoardObj = playerBoard.object
    local pos = charSheetObj.getPosition()
    pos.y = pos.y + 1
    spawnObject({
        type = "bag",
        position = pos,
        callback_function = function(bag)
            bag.setName(charSheet:NameOrUnnamed().." Cards")
            bag.setGMNotes("Character Cards")

            local packedCards = {}
            for _, card in ipairs(cards) do
                local name = card.getName()
                local pos = playerBoardObj.positionToLocal(card.getPosition())
                Log.Debugf("Scooping %s at %s into bag", name, pos)
                if not packedCards[name] then
                    packedCards[name] = {}
                end
                table.insert(packedCards[name], { pos, card.getRotation() })
                bag.putObject(card)
            end

            if playerBoard.figurine then
                local figurine = playerBoard.figurine
                Log.Debugf("Scooping figurine %s (%s) into bag", figurine.getName(), figurine.getGUID())
                playerBoard:UnlinkFigurine() -- putting it into a bag should take care of this, but just in case
                bag.putObject(figurine)
            end

            charSheet:SetPackedData(bag, packedCards)
        end
    })
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_TakeNextLocation(playerPrefix, gmNotes, availableLocations)
    if gmNotes == "Disorders" then
        for i = 1, 3 do
            local key = playerPrefix.." Disorder "..i
            if availableLocations[key] then
                availableLocations[key] = nil
                return key
            end
        end
        Log.Printf("How'd you get four disorders?")

    elseif gmNotes == "Fighting Arts" or gmNotes == "Secret Fighting Arts" then
        for i = 1, 3 do
            local key = playerPrefix.." Fighting Art "..i
            if availableLocations[key] then
                availableLocations[key] = nil
                return key
            end
        end
        Log.Printf("How'd you get four fighting arts?")

    elseif gmNotes == "Weapon Proficiencies" then
        local key = playerPrefix.." Weapon Proficiency"
        if availableLocations[key] then
            availableLocations[key] = nil
            return key
        end
    end

    for i = 1, 9 do
        local key = playerPrefix.." Ability/Impairment "..i
        if availableLocations[key] then
            availableLocations[key] = nil
            return key
        end
    end
end

---------------------------------------------------------------------------------------------------

function PlayerBoardClass.UnpackCharSheet(playerBoard)
    local charSheet = playerBoard.linkedCharSheet
    local charSheetObj = charSheet.object

    local packedBag, packedCards = charSheet:PackedData()
    if not packedCards then
        return
    end

    Log.Debugf("Unpacking character sheet %s (%s)", charSheetObj.getName(), charSheetObj.getGUID())

    local playerPrefix = "Player "..playerBoard.playerNumber
    local availableLocations = {}
    for i = 1, 3 do availableLocations[playerPrefix.." Disorder "..i] = true end
    for i = 1, 3 do availableLocations[playerPrefix.." Fighting Art "..i] = true end
    availableLocations[playerPrefix.." Weapon Proficiency"] = true
    for i = 1, 9 do availableLocations[playerPrefix.." Ability/Impairment "..i] = true end

    local playerBoardObj = playerBoard.object
    for _, bagEntry in ipairs(packedBag.getObjects()) do
        if bagEntry.gm_notes == "Player Figurine" then
            local pos = NamedObject.Get(playerPrefix.." Marker").getBounds().center
            pos.y = pos.y + 0.5
            local figurine = packedBag.TakeObject({
                position = pos,
                guid = bagEntry.guid,
                smooth = false,
            })
            playerBoard:LinkFigurine(figurine)
        else
            local packedCard = packedCards[bagEntry.name]
            if packedCard and #packedCard >= 1 then
                local pos = playerBoardObj.positionToWorld(packedCard[#packedCard][1])
                local rot = packedCard[#packedCard][2]
                Log.Debugf("Taking %s to %s", bagEntry.name, pos)
                packedBag.takeObject({
                    position = pos,
                    -- necessary hack because the char sheet "owns" the table, other we'll get an error about resources owned by different scripts
                    -- this also needs to be x/y/z not 1/2/3 since this will be loaded from json and it only saves x/y/z
                    rotation = { rot.x, rot.y, rot.z },
                    guid     = bagEntry.guid,
                    smooth   = false,
                })
                packedCard[#packedCard] = nil

                for _, zone in ipairs(Zone.Get(pos)) do
                    Log.Debugf("Card %s (%s) now occupies location %s", bagEntry.name, bagEntry.guid, zone)
                    availableLocations[zone] = false
                end
            end
        end
    end

    Log.Debugf("Available Locations: %s", Util.TabStr(availableLocations))

    local remainingObjects = packedBag.getObjects()
    local deleteBag = true
    if #remainingObjects > 0 then
        for _, bagEntry in ipairs(remainingObjects) do
            local location = PlayerBoard_TakeNextLocation(playerPrefix, bagEntry.gm_notes, availableLocations)
            if not location then
                Log.Errorf("Couldn't place %s (%s); no more space!", bagEntry.name, bagEntry.tag)
                deleteBag = false
            else
                local pos = Location.Get(location):Center()
                pos.y = pos.y + 0.5
                Log.Debugf("Taking %s to %s", bagEntry.name, pos)
                packedBag.takeObject({
                    position = pos,
                    -- necessary hack because the char sheet "owns" the table, other we'll get an error about resources owned by different scripts
                    -- this also needs to be x/y/z not 1/2/3 since this will be loaded from json and it only saves x/y/z
                    rotation = { x = 0, y = 180, z = 0 },
                    guid     = bagEntry.guid,
                    smooth   = false,
                })
            end
        end
    end

    if deleteBag then
        Log.Debugf("Destroying packed bag %s (%s)", packedBag.getName(), packedBag.getGUID())
        packedBag.destruct()
    else
        Log.Errorf("Some items in the character bag couldn't be automatically unpacked. Please take them out then delete the bag.")
        local pos = charSheetObj.getPosition()
        pos.y = pos.y + 2
        packedBag.setPositionSmooth(pos, false, true)
        Util.Highlight(packedBag)
    end

    charSheet:ClearPackedData()
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_UpdateCharSheetTemporaryModifier(playerBoard, stat)
    if playerBoard.linkedCharSheet == nil then
        return
    end

    local total = 0
    for _, token in pairs(playerBoard.linkedTemporaryTokens) do
        if token.stat == stat then
            total = total + token.value
        end
    end

    playerBoard.linkedCharSheet:SetTemporaryModifier(stat, total)
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_UpdateCharSheetPermanentModifier(playerBoard, stat)
    if playerBoard.linkedCharSheet == nil then
        return
    end

    local total = 0
    for _, token in pairs(playerBoard.linkedPermanentTokens) do
        if token.stat == stat then
            total = total + token.value
        end
    end

    playerBoard.linkedCharSheet:SetPermanentModifier(stat, total)
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_UpdateCharSheetModifiers(playerBoard)
    local charSheet = playerBoard.linkedCharSheet
    if charSheet == nil then
        return
    end

    Log.Debugf("Updating all CharSheet modifiers for %s, charSheet %s", playerBoard.object.getName(), charSheet.object.getGUID())

    local tempMods = {}
    for _, token in pairs(playerBoard.linkedTemporaryTokens) do
        tempMods[token.stat] = (tempMods[token.stat] or 0) + token.value
    end

    local permMods = {}
    for _, token in pairs(playerBoard.linkedPermanentTokens) do
        permMods[token.stat] = (permMods[token.stat] or 0) + token.value
    end

    charSheet:SetModifiers(tempMods, permMods)
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_ForFigurine(figurine)
    for _, playerBoard in ipairs(PlayerBoard_playerBoards) do
        if playerBoard.figurine == figurine then
            return playerBoard
        end
    end
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_OnObjectEnterContainer(_, object)
    local playerBoard = PlayerBoard_ForFigurine(object)
    if playerBoard then
        playerBoard:UnlinkFigurine(object)
    end
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_OnObjectDestroy(object)
    local playerBoard = PlayerBoard_ForFigurine(object)
    if playerBoard then
        playerBoard:UnlinkFigurine(object)
    end
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_OnObjectDroppedOnMarker(playerBoard, object)
    if object.getGMNotes() == "Player Figurine" then
        playerBoard:LinkFigurine(object)
    end
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_TokenValue(token)
    local value = 1
    rot = token.getRotation()
    if rot.z >= 15 and rot.z <= 345    then
            value = -1
    end

    local qty = token.getQuantity()
    if qty >= 2 then
        value = value * qty
    end

    return value
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_OnDroppedOnPlayerBoard(playerBoard, object)
    local name = object.GetName()

    if object.tag == "Card" then
        local armorStats = Armor.Get(object.getName())
        if armorStats and not playerBoard.linkedArmor[object] then
            Log.Debugf("Linking armor %s (%s) to %s with armor {%d, %d, %d, %d, %d}", object.getName(), object.getGUID(), playerBoard.object.getName(), armorStats.head, armorStats.arms, armorStats.body, armorStats.waist, armorStats.legs)
            playerBoard.linkedArmor[object] = armorStats
            for _, hitLocation in ipairs(PLAYER_BOARD_ARMOR_LOCATIONS) do
                playerBoard:AddArmor(hitLocation, 0, armorStats[hitLocation])
            end
            -- seems weird, but we actually have no need to track armor in the gear grid
        end

        local weaponStats = Weapon.Get(object.getName())
        if weaponStats and not playerBoard.linkedWeapons[object] then
            local zones = Zone.Get(object.getPosition())
            local gearCell = PlayerBoard_GearCellFromZones(zones)
            Log.Debugf("Linking weapon %s (%s) to %s on gear grid %s", object.getName(), object.getGUID(), playerBoard.object.getName(), gearCell and gearCell.name or "<none>")
            if gearCell then
                gearCell.weapon = object
            end
            playerBoard.linkedWeapons[object] = { stats = weaponStats, gearCell = gearCell }
            EventManager.FireEvent("onPlayerBoardLinkWeapon", playerBoard, object)
        end

        return
    end

    local stat = PLAYER_BOARD_TOKEN_STATS[name]
    if stat then
        local zones = Zone.Get(object.getPosition())
        local gearCell = PlayerBoard_GearCellFromZones(zones)
        if gearCell then
            Log.Debugf("Linking gear token %s (%s) to %s at gear grid %s", name, object.getGUID(), playerBoard.object.getName(), gearCell.name)
            playerBoard.linkedGearTokens[object] = gearCell
            gearCell.tokens[object] = { stat = stat, value = PlayerBoard_TokenValue(object) }
            if gearCell.weapon then
                EventManager.FireEvent("onPlayerBoardUpdateWeapon", playerBoard, gearCell.weapon)
            end

        elseif Util.ArrayContains(zones, "Player "..playerBoard.playerNumber.." Permanent Tokens") then
            Log.Debugf("Linking permanent token %s (%s) to %s", name, object.getGUID(), playerBoard.object.getName())
            playerBoard.linkedPermanentTokens[object] = { stat = stat, value = PlayerBoard_TokenValue(object) }
            PlayerBoard_UpdateCharSheetPermanentModifier(playerBoard, stat)

        else
            Log.Debugf("Linking temporary token %s (%s) to %s", name, object.getGUID(), playerBoard.object.getName())
            playerBoard.linkedTemporaryTokens[object] = { stat = stat, value = PlayerBoard_TokenValue(object) }
            PlayerBoard_UpdateCharSheetTemporaryModifier(playerBoard, stat)
        end
        object.registerCollisions() -- hack to track flips
        return
    end

    if name == "Bleeding Token" or name == "Lunacy Token" then
        Log.Debugf("Linking misc token %s (%s) to %s", name, object.getGUID(), playerBoard.object.getName())
        playerBoard.linkedMiscTokens[object] = object
        return
    end

    if object.getGMNotes() == "Character Sheet" then
        if playerBoard.linkedCharSheet then
            Log.Debugf("%s already linked to CharSheet %s", playerBoard.object.getName(), playerBoard.linkedCharSheet.object.getGUID())
            return
        end

        local charSheet = CharSheet.ForObject(object)
        if not charSheet then
            Log.Errorf("Character sheet %s dropped on %s didn't register, try picking up and dropping again. If this continues, you may need to recreate this character sheet.", object.getGUID(), playerBoard.object.getName())
            return
        end

        Log.Debugf("Linking char sheet %s (%s) to %s", object.getName(), object.getGUID(), playerBoard.object.getName())
        playerBoard.linkedCharSheet = charSheet
        PlayerBoard_UpdateCharSheetModifiers(playerBoard)
        playerBoard:UnpackCharSheet()
        if playerBoard.figurine then
            charSheet:LinkFigurine(playerBoard.figurine)
        end

        EventManager.FireEvent("onPlayerBoardLinkCharSheet", playerBoard, charSheet)
        return
    end
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_OnObjectPickedUpFromPlayerBoard(playerBoard, object)
    local armorStats = playerBoard.linkedArmor[object]
    if armorStats then
        Log.Debugf("Unlinking armor %s (%s) from %s with armor {%d, %d, %d, %d, %d}", object.getName(), object.getGUID(), playerBoard.object.getName(), armorStats.head, armorStats.arms, armorStats.body, armorStats.waist, armorStats.legs)
        playerBoard.linkedArmor[object] = nil
        for _, location in ipairs(PLAYER_BOARD_ARMOR_LOCATIONS) do
            playerBoard:AddArmor(location, 0, -armorStats[location])
        end
    end

    local weaponStats = playerBoard.linkedWeapons[object]
    if weaponStats then
        local gearCell = playerBoard.linkedWeapons[object].gearCell
        Log.Debugf("Unlinking weapon %s (%s) from %s at gear grid %s", object.getName(), object.getGUID(), playerBoard.object.getName(), gearCell and gearCell.name or "<none>")
        if gearCell then
            gearCell.weapon = nil
        end
        playerBoard.linkedWeapons[object] = nil
        EventManager.FireEvent("onPlayerBoardUnlinkWeapon", playerBoard, object)
    end

    local gearCell = playerBoard.linkedGearTokens[object]
    if gearCell then
        Log.Debugf("Unlinking gear token %s (%s) from %s at gear grid %s", object.getName(), object.getGUID(), playerBoard.object.getName(), gearCell.name)
        playerBoard.linkedGearTokens[object] = nil
        gearCell.tokens[object] = nil
        if gearCell.weapon then
            EventManager.FireEvent("onPlayerBoardUpdateWeapon", playerBoard, gearCell.weapon)
        end
        object.unregisterCollisions()   -- hack to turn off flip tracking
        return
    end

    local token = playerBoard.linkedTemporaryTokens[object]
    if token then
        Log.Debugf("Unlinking temporary token %s (%s) from %s", object.getName(), object.getGUID(), playerBoard.object.getName())
        playerBoard.linkedTemporaryTokens[object] = nil
        PlayerBoard_UpdateCharSheetTemporaryModifier(playerBoard, token.stat)
        object.unregisterCollisions()   -- hack to turn off flip tracking
        return
    end

    local token = playerBoard.linkedPermanentTokens[object]
    if token then
        Log.Debugf("Unlinking permanent token %s (%s) from %s", object.getName(), object.getGUID(), playerBoard.object.getName())
        playerBoard.linkedPermanentTokens[object] = nil
        PlayerBoard_UpdateCharSheetPermanentModifier(playerBoard, token.stat)
        object.unregisterCollisions()   -- hack to turn off flip tracking
        return
    end

    local token = playerBoard.linkedMiscTokens[object]
    if token != nil then
        Log.Debugf("Unlinking misc token %s (%s) from %s", object.getName(), object.getGUID(), playerBoard.object.getName())
        playerBoard.linkedMiscTokens[object] = nil
        return
    end

    local charSheet = playerBoard.linkedCharSheet
    if charSheet and charSheet.object == object then
        Log.Debugf("Unlinking char sheet %s from %s", charSheet.object.getGUID(), playerBoard.object.getName())
        charSheet:SetModifiers({}, {})
        charSheet:UnlinkFigurine()
        playerBoard.linkedCharSheet = nil
        EventManager.FireEvent("onPlayerBoardUnlinkCharSheet", playerBoard, charSheet)
        return
    end
 end

---------------------------------------------------------------------------------------------------

function PlayerBoard_OnObjectCollisionEnter(object, collisionInfo)
    -- This is a hack to detect flipped tokens
    -- There's no onFlip event, and flipping doesn't trigger onPickUp, so we rely on this to detect flips
    -- of *already registered* tokens.

    local collisionObject = collisionInfo.collision_object

    Log.Debugf("%s (%s) collided with %s (%s)", object.getName(), object.getGUID(), collisionObject.getName(), collisionObject.getGUID())

    local playerBoard = PlayerBoard_playerBoardsByObject[collisionObject]
    if playerBoard == nil then
        return
    end

    local gearCell = playerBoard.linkedGearTokens[object]
    if gearCell then
        local token = gearCell.tokens[object]
        assert(token, "Token %s (%s) was linked to gear grid %s, but was not in gear grid table", object.getName(), object.getGUID(), gearCell.name)

        local oldValue = token.value
        local newValue = PlayerBoard_TokenValue(object)
        if newValue != oldValue then
            Log.Debugf("Token %s (%s) flipped on %s (%s)", object.getName(), object.getGUID(), collisionObject.getName(), collisionObject.getGUID())
            token.value = newValue
            if gearCell.weapon then
                EventManager.FireEvent("onPlayerBoardUpdateWeapon", playerBoard, gearCell.weapon)
            end
        end
    end

    local token = playerBoard.linkedTemporaryTokens[object]
    if token then
        local oldValue = token.value
        local newValue = PlayerBoard_TokenValue(object)
        if newValue != oldValue then
            Log.Debugf("Token %s (%s) flipped on %s (%s)", object.getName(), object.getGUID(), collisionObject.getName(), collisionObject.getGUID())
            token.value = newValue
            PlayerBoard_UpdateCharSheetTemporaryModifier(playerBoard, token.stat)
        end
    end

    local token = playerBoard.linkedPermanentTokens[object]
    if token then
        local oldValue = token.value
        local newValue = PlayerBoard_TokenValue(object)
        if newValue != oldValue then
            Log.Debugf("Token %s (%s) flipped on %s (%s)", object.getName(), object.getGUID(), collisionObject.getName(), collisionObject.getGUID())
            token.value = newValue
            PlayerBoard_UpdateCharSheetPermanentModifier(playerBoard, token.stat)
        end
    end
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_Init(saveState, expansions, modules)
    CharSheet = modules.CharSheet
    assert(CharSheet)
    Armor = modules.Armor
    assert(Armor)
    Weapon = modules.Weapon
    assert(Weapon)

    saveState = saveState or {}
    for playerNumber = 1, 4 do
        local playerPrefix = "Player "..playerNumber
        local playerBoardObj = NamedObject.Get(playerPrefix.." Board")
        local playerBoard = PlayerBoard_Create(playerNumber, playerBoardObj, saveState[playerNumber])
        PlayerBoard_playerBoardsByObject[playerBoardObj] = playerBoard
        PlayerBoard_playerBoards[playerNumber] = playerBoard
    end
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_PostInit()
    for playerNumber = 1, 4 do
        local playerPrefix = "Player "..playerNumber
        local playerBoard = PlayerBoard_playerBoards[playerNumber]

        local locations = {
            playerPrefix.." Gear 1 1",
            playerPrefix.." Gear 1 2",
            playerPrefix.." Gear 1 3",
            playerPrefix.." Gear 2 1",
            playerPrefix.." Gear 2 2",
            playerPrefix.." Gear 2 3",
            playerPrefix.." Gear 3 1",
            playerPrefix.." Gear 3 2",
            playerPrefix.." Gear 3 3",
            playerPrefix.." Fist & Tooth",
            playerPrefix.." Disorder 1",
            playerPrefix.." Disorder 2",
            playerPrefix.." Disorder 3",
            playerPrefix.." Fighting Art 1",
            playerPrefix.." Fighting Art 2",
            playerPrefix.." Fighting Art 3",
            playerPrefix.." Weapon Proficiency",
            playerPrefix.." Ability/Impairment 1",
            playerPrefix.." Ability/Impairment 2",
            playerPrefix.." Ability/Impairment 3",
            playerPrefix.." Ability/Impairment 4",
            playerPrefix.." Ability/Impairment 5",
            playerPrefix.." Ability/Impairment 6",
            playerPrefix.." Ability/Impairment 7",
            playerPrefix.." Ability/Impairment 8",
            playerPrefix.." Ability/Impairment 9",
            playerPrefix.." Temporary Tokens",
            playerPrefix.." Permanent Tokens",
        }
        for _, location in ipairs(locations) do
            Zone.Add({ name = location, location = Location.Get(location) })
        end

        Zone.Add({
            name = playerPrefix.." Board",
            location = Location.CreateFromObject(playerBoard.object),
            dropHandler = function(object) PlayerBoard_OnDroppedOnPlayerBoard(playerBoard, object) end,
            pickUpHandler = function(object) PlayerBoard_OnObjectPickedUpFromPlayerBoard(playerBoard, object) end,
        })

        Zone.Add({
            name = playerPrefix.." Marker",
            location = Location.CreateFromObject(NamedObject.Get(playerPrefix.." Marker")),
            dropHandler = function(object) PlayerBoard_OnObjectDroppedOnMarker(playerBoard, object) end,
        })
    end

    EventManager.AddHandler("onObjectCollisionEnter", PlayerBoard_OnObjectCollisionEnter)
    EventManager.AddHandler("onObjectEnterContainer", PlayerBoard_OnObjectEnterContainer)
    EventManager.AddHandler("onObjectDestroy", PlayerBoard_OnObjectDestroy)
end

---------------------------------------------------------------------------------------------------

function PlayerBoard_Save()
    local saveState = {}
    for i, playerBoard in ipairs(PlayerBoard_playerBoards) do
        saveState[i] = playerBoard:Save()
    end
    return saveState
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_ForPlayer(playerNumber)
    assert(CheckNum(playerNumber))
    return PlayerBoard_playerBoards[playerNumber]
end

---------------------------------------------------------------------------------------------------

local function PlayerBoard_ForCharSheet(charSheet)
    assert(CheckTagged(charSheet, "CharSheet"))
    for i = 1, 4 do
        if PlayerBoard_playerBoards[i].charSheet == charSheet then
            return PlayerBoard_playerBoards[i]
        end
    end
end

---------------------------------------------------------------------------------------------------

return {
    Init = PlayerBoard_Init,
    PostInit = PlayerBoard_PostInit,
    Save = PlayerBoard_Save,
    ForPlayer = PlayerBoard_ForPlayer,
    ForFigurine = PlayerBoard_ForFigurine,
}
