local Assert = require("Kdm/Util/Assert")
local Log = require("Kdm/Util/Log").ForPackage("Rules")
local Util = require("Kdm/Util/Util")
local CircularArray = require("Kdm/Util/CircularArray")
local Trie = require("Kdm/Util/Trie")
local Archive = require("Kdm/Archive")
local Action = require("Kdm/Action")
local Locations = require("Kdm/Locations")
local Ui = require("Kdm/XmlUi")

---------------------------------------------------------------------------------------------------

Rules = {
    trie = Trie.Create(),
    history = CircularArray.Create(100),
    index = {},
}

---------------------------------------------------------------------------------------------------

function Rules.RegisterExpansion(expansion)
    for rulebookIndex, rulebook in ipairs(expansion.rulebooks or {}) do
        local rulebookName = rulebook.name
        Assert.Str(rulebookName, "rulebook.name")

        local pages = rulebook.pages
        Assert.Tab(rulebook.pages)

        for pageName, pageData in pairs(pages) do
            Assert.Str(pageName, "rulebooks[%s].pages[pageName]", rulebookName)
            local state = pageData.state
            Assert.Num(state, "rulebooks[%s].pages[%s].state", rulebookName, pageName)

            Assert(Rules.index[pageName] == nil, "Rulebook page %s is already registered to %s", pageName, Rules.index[pageName])
            Rules.index[pageName] = { rulebook = rulebookName, state = state }

            local keywords = pageData.keywords
            Assert.Tab(keywords, "rulebooks[%s].pages[%s].keywords", rulebookName, pageName)

            local entry = {
                rulebook = rulebookName,
                name = pageName,
                state = state,
                timelineEvent = pageData.timelineEvent,
                showdown = pageData.showdown,
            }

            for keywordIndex, keyword in ipairs(keywords) do
                Assert.Str(keyword, "rulebooks[%s].pages[%s].keywords[%d]", rulebookName, pageName, keywordIndex)
                Trie.Set(Rules.trie, keyword, entry)
            end

            if pageData.huntEventStart then
                local huntEventStart = pageData.huntEventStart
                Assert.Num(huntEventStart, "rulebooks[%s].pages[%s].huntEventStart", rulebookName, pageName, keywordIndex)

                local huntEventEnd = pageData.huntEventEnd
                Assert.Num(huntEventEnd, "rulebooks[%s].pages[%s].huntEventEnd", rulebookName, pageName, keywordIndex)

                for huntEventNumber = huntEventStart, huntEventEnd do
                    Trie.Set(Rules.trie, tostring(huntEventNumber), entry)
                end
            end
        end
    end
end

---------------------------------------------------------------------------------------------------

function Rules.GetRulebookAndState(name)
    local data = Rules.index[name]
    Assert(data, "Unknown rule: %s", name)
    return data.rulebook, data.state
end

---------------------------------------------------------------------------------------------------

function Rules.Search(searchTerms)
    return Trie.Search(Rules.trie, searchTerms)
end

---------------------------------------------------------------------------------------------------

function Rules.SpawnRules(rules, state, dontRecordHistory)
    Assert.Str(rules, "rules")
    Assert.Num(state, "state")
    Assert.BoolOrNil(dontRecordHistory, "dontRecordHistory")

    Log.Debugf("Spawning rules %s[%d]", rules, state)

    local blocking = Action.BoxClean({ location = "Rules Board", types = { "Rulebook" } })
    if #blocking > 0 then
        Log.Broadcastf("Something is blocking the rules board. Please move the highlighted objects out of the way and try again.")
        Util.HighlightAll(blocking)
        return
    end

    Archive.Take({ name = rules, type = "Rulebook", location = "Rules Board", spawnFunc = (state > 1) and function(obj) obj.setState(state) end or nil })
    Archive.CleanupBags()

    if not dontRecordHistory then
        CircularArray.Push(Rules.history, { rules, state })
    end
end

---------------------------------------------------------------------------------------------------

function Rules.GetCurrentRules()
    local hits = Locations.RayCast("Rules Board")
    for _, hit in ipairs(hits) do
        local hitObj = hit.hit_object
        if hitObj.getGMNotes() == "Rulebook" then
            return hitObj
        end
    end
    return nil
end

---------------------------------------------------------------------------------------------------

function Rules.Back()
    local rules = Rules.GetCurrentRules()
    if not rules then
        return
    end

    if CircularArray.Size(Rules.history) <= 1 then
        Log.Debugf("<= 1 history element, can't go back")
        return
    end

    CircularArray.Pop(Rules.history)
    local last = CircularArray.Top(Rules.history)
    Log.Debugf("Going back to %s[%d]", last[1], last[2])
    Rules.SpawnRules(last[1], last[2], true)   -- dontRecordHistory
end

---------------------------------------------------------------------------------------------------

function Rules.ChangePage(dir)
    local rules = Rules.GetCurrentRules()
    if not rules then
        return
    end

    local currentState = rules.getStateId()
    local nextState = currentState + dir
    Log.Debugf("Found current rules %s (%s) at state %d, looking for state %d", rules.getName(), rules.getGUID(), currentState, nextState)

    local rulebookName = (currentState == 1) and rules.getName() or nil
    local hasNext = false
     for _, state in ipairs(rules.getStates()) do
        if state.id == 1 then
            rulebookName = state.name
        end
        if state.id == nextState then
            Log.Debugf("Found next state %d: %s", state.id, state.name)
            hasNext = true
        end
    end

    if not hasNext then
        Log.Debugf("No state %d", nextState)
        return
    end

    Assert(rulebookName, "No rulebook name (page with state 1) in %s (%s)", rules.getName(), rules.getGUID())

    CircularArray.Push(Rules.history, { rulebookName, nextState })
    rules.setState(nextState)
end

function Rules.PreviousPage() Rules.ChangePage(-1) end
function Rules.NextPage() Rules.ChangePage(1) end

---------------------------------------------------------------------------------------------------

function Rules.SetSearchResults(results)
    if #results == 0 then
        Rules.searchResultsPanel:Hide()
        return
    end

    Rules.searchResultsPanel:Show()
    Rules.searchResultsPanel:SetHeight(10 + (#results * 30))

    for i = 1, Util.Min(5, #results) do
        local result = results[i]
        local button = Rules.searchResultButtons[i]
        button:Show()
        button:SetOnClick(function()
            Rules.searchInput:SetText(nil)
            Rules.SetSearchResults({})
            Rules.SpawnRules(result.rulebook, result.state)
        end)
        button:SetText(result.name)
    end

    for i = #results + 1, 5 do
        local button = Rules.searchResultButtons[i]
        button:Hide()
        button:SetOnClick(nil)
        button:SetText(nil)
    end
end

---------------------------------------------------------------------------------------------------

function Rules.Init(saveState, ui)
    local rules = Rules.GetCurrentRules()
    if rules != nil then
        local currentState = rules.getStateId()
        local rulebookName = nil
        if currentState == 1 then
            rulebookName = rules.getName()
        else
            for _, state in ipairs(rules.getStates()) do
                if state.id == 1 then
                    rulebookName = state.name
                end
            end
        end
        Assert(rulebookName, "No rules page with state 1 in %s (%s)", rules.getName(), rules.getGUID())
        CircularArray.Push(Rules.history, { rulebookName, currentState})
    end

    local xStart = 80+110
    Rules.searchInput = Ui.Input(ui, { id = "Rules_Search", rectAlignment = "UpperLeft", x = xStart, y = -50, width = 250, placeholder = "search rules/events...", textColor = "#000000", textOffset = "5 5 0 0", onValueChanged = function(value)
        Rules.SetSearchResults(Rules.Search(value))
    end })
    Ui.Button(ui, { id = "Rules_CancelSearch", rectAlignment = "UpperLeft", x = xStart+250+5, y = -50, width = 30, height = 30, text = "X", textAlignment = "MiddleCenter", fontSize = 20, onClick = function()
        Rules.SetSearchResults({})
        Rules.searchInput:SetText(nil)
    end })
    Rules.searchResultsPanel = Ui.Panel(ui, { id = "Rules_SearchResults", rectAlignment = "UpperLeft", x = xStart, y = -90, width = 300, height = 160, color = "#00000088", active = false })

    Rules.searchResultButtons = {}
    for i = 1, 5 do
        Rules.searchResultButtons[i] = Ui.Button(Rules.searchResultsPanel, { id = "Result"..i, rectAlignment = "UpperLeft", x = 5, y = -5 + (i - 1) * -30, width = 290, height = 30, fontSize = 16, colors = Ui.INVISIBLE_BUTTON_COLORS, textColor = "#dddddd" })
    end
end

---------------------------------------------------------------------------------------------------

return Rules
