local Assert = require("Kdm/Util/Assert")
local Log = require("Kdm/Util/Log").ForPackage("Rules")
local Util = require("Kdm/Util/Util")
local CircularArray = require("Kdm/Util/CircularArray")
local Trie = require("Kdm/Util/Trie")
local Script = require("Kdm/Script")
local Locations = require("Kdm/Locations")
local Ui = require("Kdm/XmlUi")

---------------------------------------------------------------------------------------------------

Rules = {
    trie = Trie.Create(),
    history = CircularArray.Create(100),
    index = {},
}

---------------------------------------------------------------------------------------------------

function Rules.RegisterRulebooks(rulebooks)
    Assert.TabOrNil(rulebooks, "rulebooks")
    for rulebookIndex, rulebook in ipairs(rulebooks or {}) do
        local rulebookName = rulebook.name
        Assert.Str(rulebookName, "rulebook.name")

        local pages = rulebook.pages
        Assert.Tab(rulebook.pages)

        for pageName, pageData in pairs(pages) do
            Assert.Str(pageName, "rulebooks[%s].pages[pageName]", rulebookName)
            local state = pageData.state
            Assert.Num(state, "rulebooks[%s].pages[%s].state", rulebookName, pageName)

            Assert(Rules.index[pageName] == nil, "Rulebook page %s is already registered to %s", pageName, Rules.index[pageName])
            Rules.index[pageName] = { rulebook = rulebookName, state = state }

            local keywords = pageData.keywords
            Assert.Tab(keywords, "rulebooks[%s].pages[%s].keywords", rulebookName, pageName)

            local entry = { rulebook = rulebookName, name = pageName, state = state }

            for keywordIndex, keyword in ipairs(keywords) do
                Assert.Str(keyword, "rulebooks[%s].pages[%s].keywords[%d]", rulebookName, pageName, keywordIndex)
                Trie.Set(Rules.trie, keyword, entry)
            end

            if pageData.huntEventStart then
                local huntEventStart = pageData.huntEventStart
                Assert.Num(huntEventStart, "rulebooks[%s].pages[%s].huntEventStart", rulebookName, pageName, keywordIndex)

                local huntEventEnd = pageData.huntEventEnd
                Assert.Num(huntEventEnd, "rulebooks[%s].pages[%s].huntEventEnd", rulebookName, pageName, keywordIndex)

                for huntEventNumber = huntEventStart, huntEventEnd do
                    Trie.Set(Rules.trie, tostring(huntEventNumber), entry)
                end
            end
        end
    end
end

---------------------------------------------------------------------------------------------------

function Rules.GetRulebookAndState(name)
    local data = Rules.index[name]
    Assert(data, "Unknown rule: %s", name)
    return data.rulebook, data.state
end

---------------------------------------------------------------------------------------------------

function Rules.Find(query)
    if query == nil or query == "" then
        return {}
    end

    -- only accept results that match all terms
    local matchIndex = {}
    local i = 1
    for term in string.gmatch(query, "%S+") do
        local termMatches = Trie.Find(Rules.trie, term)
        local termIndex = Util.Index(termMatches, "name")

        matchIndex = (i == 1) and termIndex or Util.Intersect(matchIndex, termIndex)
        i = i + 1
    end

    -- sort matches
    local sortedMatches = {}
    for _, m in pairs(matchIndex) do
        table.insert(sortedMatches, m)
    end
    table.sort(sortedMatches, function(x, y) return x.name < y.name end)

    local results = {}
    local i = 1
    while i <= #sortedMatches and i <= 5 do
        table.insert(results, sortedMatches[i])
        i = i + 1
    end

    return results
end

---------------------------------------------------------------------------------------------------

function Rules.SpawnRules(rules, state, dontRecordHistory)
    Rules.spawnRulebookCoroutineParams = { rules, state, dontRecordHistory }
    startLuaCoroutine(self, "Rules_SpawnRulesCoroutine")
end

function Rules_SpawnRulesCoroutine()
    local rules, state, dontRecordHistory = table.unpack(Rules.spawnRulebookCoroutineParams)
    Assert.Str(rules, "rules")
    Assert.Num(state, "state")
    Assert.BoolOrNil(dontRecordHistory, "dontRecordHistory")

    local script = Script.Create("Show Rulebook")
    local cleanStage = Script.Stage(script, "Clean")
    Script.CleanAction(cleanStage, {
        from = "Rules Board",
        types = { "Rulebook" },
        ignoreBlocking = false,
    })
    local spawnStage = Script.Stage(script, "Spawn")
    Script.TakeAction(spawnStage, {
        name = rules,
        type = "Rulebook",
        to = "Rules Board",
        spawnFunc = (state > 1) and function(obj) obj.setState(state) end or nil,
    })

    local _, blockingObj = Script.Run(script)
    if blockingObj != nil then
        Log.Broadcastf("Found an object %s(%s) blocking the rules board. Please move it out of the way and try again.", blockingObj.getName(), blockingObj.tag)
        return 1
    end

    if not dontRecordHistory then
        CircularArray.Push(Rules.history, { rules, state})
    end

    return 1
end

---------------------------------------------------------------------------------------------------

function Rules.GetCurrentRules()
    local hits = Locations.RayCast("Rules Board")
    for _, hit in ipairs(hits) do
        local hitObj = hit.hit_object
        if hitObj.getGMNotes() == "Rulebook" then
            return hitObj
        end
    end
    return nil
end

---------------------------------------------------------------------------------------------------

function Rules.Back()
    local rules = Rules.GetCurrentRules()
    if not rules then
        return
    end

    if CircularArray.Size(Rules.history) <= 1 then
        Log.Debugf("<= 1 history element, can't go back")
        return
    end

    CircularArray.Pop(Rules.history)
    local last = CircularArray.Top(Rules.history)
    Log.Debugf("Going back to %s[%d]", last[1], last[2])
    Rules.SpawnRules(last[1], last[2], true)   -- dontRecordHistory
end

---------------------------------------------------------------------------------------------------

function Rules.ChangePage(dir)
    local rules = Rules.GetCurrentRules()
    if not rules then
        return
    end

    local currentState = rules.getStateId()
    local nextState = currentState + dir
    Log.Debugf("Found current rules %s (%s) at state %d, looking for state %d", rules.getName(), rules.getGUID(), currentState, nextState)

    local rulebookName = (currentState == 1) and rules.getName() or nil
    local hasNext = false
     for _, state in ipairs(rules.getStates()) do
        if state.id == 1 then
            rulebookName = state.name
        end
        if state.id == nextState then
            Log.Debugf("Found next state %d: %s", state.id, state.name)
            hasNext = true
        end
    end

    if not hasNext then
        Log.Debugf("No state %d", nextState)
        return
    end

    Assert(rulebookName, "No rulebook name (page with state 1) in %s (%s)", rules.getName(), rules.getGUID())

    CircularArray.Push(Rules.history, { rulebookName, nextState })
    rules.setState(nextState)
end

function Rules.PreviousPage() Rules.ChangePage(-1) end
function Rules.NextPage() Rules.ChangePage(1) end

---------------------------------------------------------------------------------------------------

function Rules_SearchInput_OnValueChanged(_, value)
    Rules_SetSearchResults(Rules.Find(value))
end

---------------------------------------------------------------------------------------------------

function Rules_CancelSearchButton_OnClick()
    Rules_SetSearchResults({})
    self.UI.setAttribute("Rules_SearchInput", "text", nil)
end

---------------------------------------------------------------------------------------------------

function Rules_SearchResult_Click(rulebook, state)
    Rules_SetSearchResults({})
    self.UI.setAttribute("Rules_SearchInput", "text", nil)
    Rules.SpawnRules(rulebook, state)
end

---------------------------------------------------------------------------------------------------

function Rules_SetSearchResults(results)
    if #results == 0 then
        self.UI.hide("Rules_SearchResultsPanel")
        return
    end

    self.UI.show("Rules_SearchResultsPanel")

    for i, result in ipairs(results) do
        local buttonId = "Rules_SearchResult"..i.."Button"
        self.UI.show(buttonId)
        self.setVar(buttonId.."_OnClick", function () Rules_SearchResult_Click(result.rulebook, result.state) end)
        self.UI.setAttributes(buttonId, {
            onClick = buttonId.."_OnClick",
            text = result.name,
            textColor = "#dddddd",
        })
    end

    self.UI.setAttribute("Rules_SearchResultsPanel", "height", 10 + (#results * 30))

    for i = #results + 1, 5 do
        local buttonId = "Rules_SearchResult"..i.."Button"
        self.UI.hide(buttonId)
        self.UI.setAttributes(buttonId, {
            onClick = nil,
            text = nil,
        })
    end
end

---------------------------------------------------------------------------------------------------

function Rules.Init(ui)
    local rules = Rules.GetCurrentRules()
    if rules != nil then
        local currentState = rules.getStateId()
        local rulebookName = nil
        if currentState == 1 then
            rulebookName = rules.getName()
        else
            for _, state in ipairs(rules.getStates()) do
                if state.id == 1 then
                    rulebookName = state.name
                end
            end
        end
        Assert(rulebookName, "No rules page with state 1 in %s (%s)", rules.getName(), rules.getGUID())
        CircularArray.Push(Rules.history, { rulebookName, currentState})
    end

    Ui.Input(ui, { id = "Rules_SearchInput", rectAlignment = "UpperLeft", x = 80, y = -50, width = 250, placeholder = "search rules/events...", textColor = "#000000", textOffset = "5 5 0 0", onValueChanged = "Rules_SearchInput_OnValueChanged" })
    Ui.Button(ui, { id = "Rules_CancelSearchButton", rectAlignment = "UpperLeft", x = 335, y = -50, width = 30, height = 30, text = "X", textAlignment = "MiddleCenter", fontSize = 20, onClick = "Rules_CancelSearchButton_OnClick" })
    local searchResultsPanel = Ui.Panel(ui, { id = "Rules_SearchResultsPanel", rectAlignment = "UpperLeft", x = 80, y = -90, width = 300, height = 160, color = "#00000088", active = false })
    for i = 1, 5 do
        log(INVISIBLE_BUTTON_COLORS)
        Ui.Button(searchResultsPanel, { id = "Rules_SearchResult"..i.."Button", rectAlignment = "UpperLeft", x = 5, y = -5 + (i - 1) * -30, width = 290, height = 30, fontSize = 16, colors = Ui.INVISIBLE_BUTTON_COLORS, textColor = "#dddddd" })
    end
end

---------------------------------------------------------------------------------------------------

return Rules
