local Check = require("Kdm/Util/Check")
local Container = require("Kdm/Util/Container")
local Expansion = require("Kdm/Expansion")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Archive")
local NamedObject = require("Kdm/NamedObject")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Archive = {}

Archive.data = {
    { "Abilities", "Abilities", "Abilities Archive" },
    { "Fighting Arts", "Fighting Arts", "Fighting Arts Archive" },
    { "Secret Fighting Arts", "Secret Fighting Arts", "Secret Fighting Arts Archive" },
    { "Disorders", "Disorders", "Disorders Archive" },
    { "Severe Injuries", "Severe Injuries", "Severe Injuries Archive" },
    { "Tactics", "Tactics", "Tactics Archive" },
    { "Weapon Proficiencies", "Weapon Proficiencies", "Weapon Proficiencies Archive" },
    { "Armor Sets", "Armor Sets", "Armor Sets Archive" },
    { "Vermin", "Vermin", "Vermin Archive" },
    { "Strange Resources", "Strange Resources", "Strange Resources Archive" },
    { "Basic Resources", "Basic Resources", "Basic Resources Archive" },
    { "Terrain", "Terrain", "Terrain Archive" },
    { "Terrain Tiles", "Terrain Tiles", "Terrain Tiles Archive" },
    { "Hunt Events", "Hunt Events", "Hunt Events Archive" },
    { "Settlement Events", "Settlement Events", "Settlement Events Archive" },
    { "Rare Gear", "Gear", "Rare Gear Archive" },
    { "All Gear", "Gear", "All Gear Archive" },
    { "Monster Resources", "Monster Resources", "Monster Resources Archive" },
    { "Survivor Sheet", "Survivor Sheet", "Survivor Sheets Archive" },
    { "Survivor Box", "Survivor Box", "Survivor Boxes Archive" },
}

---------------------------------------------------------------------------------------------------

function Archive.Init()
    Archive.index = {}
    Archive.direct = {}

    -- "Direct" entries are the items directly contained by the infinite container archive, such as the "Disorders" deck in the "Disorders Archive".
    -- For such items we just a flag telling us to take the item directly, no need to search inside it.
    for _, entry in ipairs(Archive.data) do
        local name, type, archive = entry[1], entry[2], entry[3]
        local key = Archive.Key(name, type)
        Archive.index[key] = archive
        Archive.direct[key] = true
    end

    Archive.containers = {}
    Archive.containerX = -150
    Archive.containerZ = 120

    for _, expansion in pairs(Expansion.AllExpansions()) do
        Archive.RegisterEntries(expansion.archiveEntries)
    end
end

---------------------------------------------------------------------------------------------------

function Archive.Key(name, type)
    return type.."."..name
end

---------------------------------------------------------------------------------------------------

function Archive.RegisterEntries(params)
    if not params then
        return
    end

    archive = params.archive
    assert(archive)
    for _, entry in ipairs(params.entries) do
        local name, type = entry[1], entry[2]
        assert(name)
        assert(type)
        local key = Archive.Key(name, type)
        if not params.allowOverrides then
            assert(Check(Archive.index[key] == nil, "Archive entry %s/%s for %s is already registered for %s", name, type, archive, Archive.index[key]))
        end
        Archive.index[key] = archive
    end
end

---------------------------------------------------------------------------------------------------

function Archive.NextContainerPosition()
    local position = { x = Archive.containerX, y = 15, z = Archive.containerZ }
    Archive.containerX = Archive.containerX + 10
    if Archive.containerX > 150 then
        Archive.containerX = -150
        Archive.containerZ = Archive.containerZ - 10
        if Archive.containerZ < 70 then
            Archive.containerZ = 120
        end
    end
    return position
end

---------------------------------------------------------------------------------------------------

function Archive.Take(params)
    local archive = params.archive
    local name = params.name
    local type = params.type
    local height = params.height or 2
    local location = params.location
    local position = params.position
    if location then
        location = Location.Get(location)
        position = location:Center()
        position.y = position.y + (height or 2)
    else
        assert(position, "Either location or position is required")
    end
    local rotation = params.rotation or { x = 0, y = 180, z = 0 }
    local spawnFunc = params.spawnFunc
    local allowMissing = params.allowMissing
    assert(Check.StrOrNil(archive))
    assert(Check.Str(name))
    assert(Check.Str(type))
    assert(Check.NumOrNil(height))
    assert(Check.Vec3OrNil(rotation))
    assert(Check.FuncOrNil(spawnFunc))

    if not archive then
        local key = Archive.Key(name, type)
        archive = Archive.index[key]
        if allowMissing then
            return nil
        end
        assert(Check(archive, "%s (%s) is not in the archive", name, type))

        if Archive.direct[key] then
            -- for single item archives no need to pull intermediate container
            log:Debugf("Using direct from archive %s for %s (%s)", archive, name, type)
            return NamedObject.Get(archive).takeObject({
                position = position,
                rotation = rotation,
                smooth = false,
                callback_function = spawnFunc,
            })
        end
    end

    if location then
        log:Debugf("Taking item %s (%s) in archive %s to %s +%f", name, type, archive, location:Name(), height)
    else
        log:Debugf("Taking item %s (%s) in archive %s to %s", name, type, archive, position)
    end

    local container = Archive.containers[archive]
    if container then
        log:Debugf("Re-using already-spawned archive container %s for %s (%s)", container:Guid(), name, type)

    else
        -- spawn new container and cache
        local archiveObject = NamedObject.Get(archive)
        local containerObject = archiveObject.takeObject({
            position = Archive.NextContainerPosition(),
            smooth = false,
        })
        container = Container(containerObject)
        if not container then
            log:Errorf("Couldn't take from archive %s (%s). If you accidentally reset/cleared it, then you may need to restore an earlier save. If it's one of the deck archives (Disorders, Fighting Arts, etc), you can try reconstructing the deck then dropping it onto the archive box to restore it.", archiveObject.getName(), archiveObject.getGUID())
            Util.Highlight(archiveObject)
            return nil
        end

        --log:Debugf("Spawned archive container %s at (%f, %f) for %s (%s)", container:Guid(), Archive.containerX, Archive.containerZ, name, type)
        log:Debugf("Spawned archive container %s at (%f, %f) for %s (%s)", "", Archive.containerX, Archive.containerZ, name, type)

        container:Lock(true)
        Archive.containers[archive] = container
    end

    local object = container:Take({
        name = name,
        type = type,
        position = position,
        rotation = rotation,
        spawnFunc = spawnFunc,
        allowMissing = allowMissing,
    })
    if not object then
        if not allowMissing then
            log:Errorf("Couldn't find %s (%s) in archive %s. If you accidentally reset/cleared it, then you may need to restore an earlier save. If it's one of the deck archives (Disorders, Fighting Arts, etc), you can try reconstructing the deck then dropping it onto the archive box to restore it.", name, type, archive)
            Util.Highlight(NamedObject.Get(archive))
        end
        return nil
    end

    log:Debugf("Spawned object %s (%s)", object.getName(), object.getGUID())

    return object
end

---------------------------------------------------------------------------------------------------

function Archive.CleanUpContainers()
    for _, container in pairs(Archive.containers) do
        log:Debugf("Destroying archive container %s", container:Guid())
        container:Destruct()
    end

    -- scan and clean orphaned containers from a previous error
    local hits = Physics.cast({
        origin    = { x = 0, y = 100, z = 95 },
        direction = { x = 0, y = -1, z = 0 },
        type      = 3,
        size      = { x = 350, y = 50, z = 100 },
    })
    for _, hit in ipairs(hits) do
        local obj = hit.hit_object
        if obj.tag == "Bag" and obj.getGMNotes() == "Archive Bag" then
            log:Debugf("Destroying leftover archive bag %s (%s)", obj.getName(), obj.getGUID())
            obj.destruct()
        end
        if obj.tag == "Deck" then
            local key = Archive.Key(obj.getName(), obj.getGMNotes())
            if Archive.direct[key] then
                log:Debugf("Destroying leftover archive deck %s (%s)", obj.getName(), obj.getGUID())
                obj.destruct()
            end
        end
    end

    Archive.containers = {}
    Archive.containerX = -150
    Archive.containerZ = 120
end

---------------------------------------------------------------------------------------------------

return {
    Init = Archive.Init,
    RegisterEntries = Archive.RegisterEntries,
    Take = Archive.Take,
    CleanUpContainers = Archive.CleanUpContainers,
}
