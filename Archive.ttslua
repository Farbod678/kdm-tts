local Assert = require("Kdm/Util/Assert")
local Log = require("Kdm/Util/Log").ForPackage("Archive")
local Guids = require("Kdm/Guids")

---------------------------------------------------------------------------------------------------

local Archive = {
    index = {},

    reverseIndex = {
        ["Abilities Archive"] = { { "Abilities", "Abilities" } },
        ["Fighting Arts Archive"] = { { "Fighting Arts", "Fighting Arts" } },
        ["Secret Fighting Arts Archive"] = { { "Secret Fighting Arts", "Secret Fighting Arts" } },
        ["Disorders Archive"] = { { "Disorders", "Disorders" } },
        ["Severe Injuries Archive"] = { { "Severe Injuries", "Severe Injuries" } },
        ["Tactics Archive"] = { { "Tactics", "Tactics" } },
        ["Weapon Specializations/Masteries Archive"] = { { "Weapon Specializations/Masteries", "Weapon Specializations/Masteries" } },
        ["Armor Sets Archive"] = { { "Armor Sets", "Armor Sets" } },
        ["Vermin Archive"] = { { "Vermin", "Vermin" } },
        ["Strange Resources Archive"] = { { "Strange Resources", "Strange Resources" } },
        ["Basic Resources Archive"] = { { "Basic Resources", "Basic Resources" } },
        ["Terrain Archive"] = { { "Terrain", "Terrain" } },
        ["Terrain Tiles Archive"] = { { "Terrain Tiles", "Terrain Tiles" } },
        ["Hunt Events Archive"] = { { "Hunt Events", "Hunt Events" } },
        ["Rare Gear Archive"] = { { "Rare Gear", "Gear" } },
    },

    -- These archives have no intermediate bag...you just pull the object directly
    singleItemArchives = {
        ["Abilities Archive"]                        = true,
        ["Fighting Arts Archive"]                    = true,
        ["Secret Fighting Arts Archive"]             = true,
        ["Disorders Archive"]                        = true,
        ["Severe Injuries Archive"]                  = true,
        ["Tactics Archive"]                          = true,
        ["Weapon Specializations/Masteries Archive"] = true,
        ["Armor Sets Archive"]                       = true,
        ["Vermin Archive"]                           = true,
        ["Strange Resources Archive"]                = true,
        ["Basic Resources Archive"]                  = true,
        ["Terrain Archive"]                          = true,
        ["Terrain Tiles Archive"]                    = true,
        ["Hunt Events Archive"]                      = true,
        ["Rare Gear Archive"]                        = true
    },

    bags = {},
    bagX = -150,
    bagY = -120,
}

for archive, entries in pairs(Archive.reverseIndex) do
    for _, entry in ipairs(entries) do
        local name, type = entry[1], entry[2]
        if not Archive.index[type] then
            Archive.index[type] = {}
        end
        Archive.index[type][name] = archive
    end
end

---------------------------------------------------------------------------------------------------

function Archive.RegisterArchiveEntries(archiveEntries, allowOverrides)
    if not archiveEntries then
        return
    end
    archive = archiveEntries.archive
    for _, entry in ipairs(archiveEntries.entries) do
        local name, type = entry[1], entry[2]
        if not Archive.index[type] then
            Archive.index[type] = {}
        end
        if not allowOverrides then
            Assert(Archive.index[type][name] == nil, "Archive entry %s/%s for %s is already registered for %s", name, type, archive, Archive.index[type][name])
        end
        Archive.index[type][name] = archive
    end
end

---------------------------------------------------------------------------------------------------

function Archive.GetBag(name, type)
    Assert.Str(name)
    Assert.Str(type)

    local typeIndex = Archive.index[type]
    Assert(typeIndex, "Unknown type %s", type)
    local archive = typeIndex[name]
    Assert(archive, "%s (%s) is not in the archive", name, type)

    Log.Debugf("Found %s (%s) in archive %s", name, type, archive)

    if Archive.singleItemArchives[archive] then
        -- for single item archives no need to pull intermediate bag
        Log.Debugf("Using single-item archive %s for %s (%s)", archive, name, type)
        return Guids.GetObject(archive)
    end

    local bag = Archive.bags[archive]
    if bag then
        -- reuse existing bag
        Log.Debugf("Re-using already-spawned archive bag %s (%s) for %s (%s)", bag.getName(), bag.getGUID(), name, type)
        return bag
    end

    -- spawn new bag and cache
    local bag = Guids.GetObject(archive).takeObject({
        position = { Archive.bagX, -10, Archive.bagZ },
        smooth = false,
    })
    Assert(bag, "Couldn't take from %s", archive)
    Log.Debugf("Spawned archive bag %s (%s) at (%f, %f) for %s (%s)", bag.getName(), bag.getGUID(), Archive.bagX, Archive.bagZ, name, type)

    bag.setLock(true)
    Archive.bags[archive] = bag

    Archive.bagX = Archive.bagX + 10
    if Archive.bagX > 150 then
        Archive.bagX = -150
        Archive.bagZ = Archive.bagZ - 10
        if Archive.bagZ < 70 then
            Archive.bagZ = 120
        end
    end

    return bag
end

---------------------------------------------------------------------------------------------------

function Archive.ClearBags()
    for _, bag in ipairs(Archive.bags) do
        bag.destruct()
    end

    local hits = Physics.cast({
        origin    = { 0, 10, 95 },
        direction = { 0, -1, 0 },
        type      = 3,
        size      = { 300, 10, 50 },
    })
    for _, hit in ipairs(hits) do
        local obj = hit.hit_object
        if obj.getGMNotes() == "Archive" then
            Log.Debugf("Destroying archive %s (%s)", obj.getName(), obj.getGUID())
            obj.destruct()
        end
    end

    Archive.bags = {}
    Archive.bagX = -150
    Archive.bagZ = 120
end

---------------------------------------------------------------------------------------------------


return Archive
